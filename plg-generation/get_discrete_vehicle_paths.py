import numpy as np
import classes.data as d
import functions.general as g
import functions.date_time as date_time
import time


###############################################################################
# get_discrete_vehicle_paths:                                                 #
#                                                                             #
# Purpose: In order to generate the edges of the PLG we need to convert the   #
#          continuous vehicle paths into a discrete format. This function     #
#          takes the continuous vehicle paths and converts them into a set of #
#          nodes in the PLG. A vehicle's position is associated with the node #
#          that it is closest to.                                             #
#                                                                             #
# Params: IN/OUT data - A data object of type "data" defined in               #
#                       classes/data.py which contains the cleaned dataset.   #
#                       Once we've converted the vehicle paths into a         #
#                       discretised format, we will store them in the         #
#                       data.node parameter.                                  #
#         IN/OUT PLG  - A PLG object of type "PLG" defined in classes/PLG.py. #
#                       The PLG.vehicle_paths parameter will be updated with  #
#                       the discretised vehicle paths generated by this       #
#                       function.                                             #
#                                                                             #
###############################################################################
def get_discrete_vehicle_paths(data, PLG):
    # Create a dictionary of {vehicle id : unique node list vehicle path}
    discrete_vehicle_paths = {}
    num_paths = len(data.vehicle_sese[:,0])
    nodal_data = [0 for ii in range(data.num_data_points)]
    nodes = PLG.nodes
    global_counter = 0

    # Cycle through each vehicle path and calculate it's discretised version
    for ii in range(num_paths):
        # Initialise the path for this vehicle
        vehicle_id = data.vehicle_sese[ii,0]
        # We use a dict to store the growing vehicle path because we get O(1)
        # search speed.
        vehicle_path_dict = {}

        # Get the continuous path 
        x_path = g.se_extraction(vehicle_id, data.x, data.vehicle_sese)
        y_path = g.se_extraction(vehicle_id, data.y, data.vehicle_sese)
        path_length = len(x_path)

        # Now cycle through the vehicle path
        for jj in range(path_length):
            x_jj = x_path[jj,0]
            y_jj = y_path[jj,0]
            d_jj = np.array([[x_jj, y_jj]])

            # Get the closest node to the current position
            node_jj = np.argmin(np.sqrt(np.sum(np.square(nodes - d_jj), axis=1)))

            # If this node is not already in the discrete path then append it,
            # otherwise skip it. We can get multiple instances of a node in a
            # vehicle path if, for example, a vehicle is stopped at a traffic
            # light.
            if node_jj not in vehicle_path_dict:
                vehicle_path_dict[node_jj] = True

            # We want to store the nodes to the data.node anyway because we
            # want to store a discrete version of spatial data anyway. So we
            # Will use this list to store the data and then assign it to
            # data.node.
            nodal_data[global_counter] = node_jj
            global_counter += 1

        # We've finished iterating this vehicle path. Now convert the
        # vehicle_path_dict into a list of nodes. We can do this by taking just
        # the keys of the dictionary.
        discrete_vehicle_paths[vehicle_id] = list(vehicle_path_dict.keys())

    # Objects are passed by reference so now we set the data.nodes and
    # PLG.vehicle_paths data structures here and we will save the data and PLG
    # outside objects outsde of this function in the place that this function
    # is called.
    PLG.vehicle_paths = discrete_vehicle_paths
    data.node = nodal_data

    return True


